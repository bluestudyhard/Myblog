import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as r,c as o,f as c}from"./app-xEYoAD2G.js";const d={},t=c('<h2 id="docker-基本知识" tabindex="-1"><a class="header-anchor" href="#docker-基本知识" aria-hidden="true">#</a> docker 基本知识</h2><p>容器是由镜像实例化而来，这和我们学习的面向对象的概念十分相似，我们可以把镜像看作类，把容器看作类实例化后的对象。</p><p>也可以说镜像是文件, 容器是进程。 容器是基于镜像创建的, 即容器中的进程依赖于镜像中的文件, 这里的文件包括进程运行所需要的可执行文件， 依赖软件， 库文件， 配置文件等等...<br> docker 的镜像概念类似虚拟机的镜像。是一个只读的模板，一个独立的文件系统，包括运行容器所需的数据，可以用来创建新的容器。</p><p>例如：一个镜像可以包含一个完整的 ubuntu 操作系统环境，里面仅安装了 mysql 或用户需要的其他应用程序。</p><p>docker 镜像实际上是由一层一层的系统文件组成，这种层级的文件系统被称为 UnionFS( Union file system 统一文件系统)，镜像可以基于 dockerfile 构建，dockerfile 是一个描述文件，里面包含了若干条密令，每条命令都会对基础文件系统创建新的层次结构。</p><p>docker 提供了一个很简单的机制来创建镜像或更新现有的镜像。用户甚至可以从其他人那里下载一个已经做好的镜像直接使用。（镜像是只读的，可以理解为静态文件）</p><p>docker 利用容器来运行应用：docker 容器是由 docker 镜像创建的运行实例。docker 容器类似虚拟机，可以执行包含启动，停止，删除等。每个容器间是相互隔离的。容器中会运行特定的运用，包含特定应用的代码及所需的依赖文件。可以把容器看作一个简易版的 linux 环境（包含 root 用户权限，进程空间，用户空间和网络空间等）和运行在其中的应用程序。</p><p>相对于镜像来说容器是动态的，容器在启动的时候创建了一层可写层次作为最上层。</p><p>docker 仓库：如果使用了 git 和 github 就很容易理解 docker 的仓库概念。docker 仓库概念和 git 类似。</p><p>docker 仓库是用来包含镜像的位置，docker 提供了一个注册服务器（register）来保存多个仓库，每个仓库又可以包含多个具备不同 tag 的镜像，</p><p>docker 运作中使用的默认仓库是 docker hub 公共仓库。</p><p>仓库支持的操作类似 git，当用户创建了自己的镜像之后就可以使用 push 命令将它上传到共有或者私有的仓库。这样下次再另外一台机器上使用这个镜像的时候只需要从仓库里面 pull 下来就可以了。</p><h2 id="docker-镜像" tabindex="-1"><a class="header-anchor" href="#docker-镜像" aria-hidden="true">#</a> docker 镜像</h2><h3 id="dockerfile-详解" tabindex="-1"><a class="header-anchor" href="#dockerfile-详解" aria-hidden="true">#</a> dockerfile 详解</h3><ul><li><p>ARG 相当于变量，可以在 docker build 的时候传入，例如 docker build --build-arg VERSION=1.0.0 .，这样在 dockerfile 里面就可以使用 ${VERSION} 来引用这个变量了</p></li><li><p>FROM 指定基础镜像，必须是第一个命令，后续的命令都是基于这个镜像的</p></li><li><p>RUN 表示容器启动时运行的命令，可以有多个，每个 RUN 都会在上一个 RUN 的基础上执行，例如 RUN apt-get update &amp;&amp; apt-get install -y vim</p></li><li><p>CMD 表示容器启动时运行的命令，只能有一个，如果有多个，只有最后一个生效，如果 docker run 的时候指定了命令，那么 CMD 的命令会被忽略，例如 CMD [&quot;java&quot;, &quot;-jar&quot;, &quot;app.jar&quot;]，这里的 CMD 会被忽略，因为 docker run 的时候指定了 java -jar app.jar</p></li><li><p>COPY<br> 格式为<br><code>COPY &lt;src&gt; &lt;dest&gt;。</code><br> 复制本地主机的 （为 Dockerfile 所在目录的相对路径）到容器中的 。<br> 当使用本地目录为源目录时，推荐使用 COPY。<br> 比如说copy .. 表示将dokerfile所在目录的上一级目录的所有文件复制到容器中的 /app 目录下</p></li><li><p>WORKDIR 表示容器启动时的工作目录，如果不存在会自动创建，例如 WORKDIR /app，这样在后续的命令中就可以使用相对路径了，例如 COPY . .，这里的第二个 . 就表示 /app</p></li><li><p>ENV 设置环境变量，格式为<code> ENV &lt;key&gt; &lt;value&gt;</code>，例如 ENV JAVA_OPTS=&quot;-Xms256m -Xmx512m -XX:MetaspaceSize=256m -XX:MaxMetaspaceSize=512m&quot;，这样在后续的命令中就可以使用 ${JAVA_OPTS} 来引用这个环境变量了</p></li><li><p>EXPOSE 暴露端口，格式为<code> EXPOSE &lt;port&gt; [&lt;port&gt;...]</code>，例如 EXPOSE 8080，这样在 docker run 的时候就可以使用 -p 8080:8080 来映射端口了</p></li></ul>',15),p=[t];function a(i,l){return r(),o("div",null,p)}const n=e(d,[["render",a],["__file","docker.html.vue"]]);export{n as default};
