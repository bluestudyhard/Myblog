import{_ as a}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as e,c as r,f as p}from"./app-xEYoAD2G.js";const c="/assets/20231017195803-Wtnnnwoz.png",t={},n=p('<h2 id="什么是进程" tabindex="-1"><a class="header-anchor" href="#什么是进程" aria-hidden="true">#</a> 什么是进程</h2><p>进程其实就是本质上就是系统上运行的一个程序，系统开辟出了一块内存空间，然后由 CPU 来逐行读取里面的指令，执行里面的指令</p><h3 id="进程的状态" tabindex="-1"><a class="header-anchor" href="#进程的状态" aria-hidden="true">#</a> 进程的状态</h3><p>创建态，就绪态，运行态，阻塞态，终止态</p><p>创建态，new 一个进程，分配内存空间，分配 pcb</p><p>就绪态，进程已经创建完毕，等待着 cpu 的调度</p><p>运行态，进程在 cpu 上运行</p><p>阻塞态，进程在等待着某个事件的发生，比如说等待着 IO，那么这个时候进程会被调度进入阻塞队列</p><p>阻塞态又分就绪阻塞和等待阻塞<br> 就绪阻塞在再次进入内存的时候可以直接运行<br> 等待阻塞是，在阻塞的过程中，会先把进程的 pcb 保存到外存，等待着某个事件的发生，当事件发生的时候，会把进程的 pcb 重新加载到内存，然后进入就绪态<br> 阻塞态的终止是需要另一个进程的提醒的，一个进程是不能够主动的切换阻塞状态的</p><h3 id="进程标识符-pcb" tabindex="-1"><a class="header-anchor" href="#进程标识符-pcb" aria-hidden="true">#</a> 进程标识符 pcb</h3><p>进程标识符 pcb 是进程的唯一标识符，是进程的控制块<br> 里面包含了进程的运行状态，比如说进程处于就绪态还是什么的<br> 然后包含了进程的优先级，进程的占用的资源，进程的 pid，进程的父进程的 pid，进程的子进程的 pid，进程的状态，进程的内存地址，进程的打开文件列表，进程的信号处理程序，进程的账号信息，进程的调度信息，进程的内存信息，进程的 IO 信息，进程的文件信息，进程的内核栈，进程的用户栈，进程的环境变量，进程的命令行参数，进程的工作目录，进程的 umask，进程的根目录，进程的根目录，进程的文件描述符，进程的内存映射，进程的信号屏蔽码，进程的信号队列，进程的定时器，进程的资源限制，进程的会话信息，进程的进程组信息，进程的控制终端，进程的当前工作目录，进程的根目录，进程的文件创建掩码，进程的文件系统，进程的资源使用情况，进程的进程间通信信息，进程的线程信息，进程的安全信息，进程的辅助</p><h3 id="信号量机制" tabindex="-1"><a class="header-anchor" href="#信号量机制" aria-hidden="true">#</a> 信号量机制</h3><p>pv操作必须连续出现，<br> p，表示申请资源，如果资源不够，那么就会阻塞，执行p操作，资源数+1<br> v，表示释放资源，如果资源不够，那么就会阻塞，执行v操作，资源数-1<br><img src="'+c+'" alt="" loading="lazy"></p>',13),d=[n];function i(h,s){return e(),r("div",null,d)}const b=a(t,[["render",i],["__file","进程，线程.html.vue"]]);export{b as default};
