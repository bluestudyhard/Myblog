const e=JSON.parse(`{"key":"v-475ca693","path":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B.html","title":"","lang":"zh-CN","frontmatter":{"description":"什么是进程 进程其实就是本质上就是系统上运行的一个程序，系统开辟出了一块内存空间，然后由 CPU 来逐行读取里面的指令，执行里面的指令 进程的状态 创建态，就绪态，运行态，阻塞态，终止态 创建态，new 一个进程，分配内存空间，分配 pcb 就绪态，进程已经创建完毕，等待着 cpu 的调度 运行态，进程在 cpu 上运行 阻塞态，进程在等待着某个事件的发生，比如说等待着 IO，那么这个时候进程会被调度进入阻塞队列 阻塞态又分就绪阻塞和等待阻塞 就绪阻塞在再次进入内存的时候可以直接运行 等待阻塞是，在阻塞的过程中，会先把进程的 pcb 保存到外存，等待着某个事件的发生，当事件发生的时候，会把进程的 pcb 重新加载到内存，然后进入就绪态 阻塞态的终止是需要另一个进程的提醒的，一个进程是不能够主动的切换阻塞状态的","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B.html"}],["meta",{"property":"og:site_name","content":"melingkk's blog"}],["meta",{"property":"og:description","content":"什么是进程 进程其实就是本质上就是系统上运行的一个程序，系统开辟出了一块内存空间，然后由 CPU 来逐行读取里面的指令，执行里面的指令 进程的状态 创建态，就绪态，运行态，阻塞态，终止态 创建态，new 一个进程，分配内存空间，分配 pcb 就绪态，进程已经创建完毕，等待着 cpu 的调度 运行态，进程在 cpu 上运行 阻塞态，进程在等待着某个事件的发生，比如说等待着 IO，那么这个时候进程会被调度进入阻塞队列 阻塞态又分就绪阻塞和等待阻塞 就绪阻塞在再次进入内存的时候可以直接运行 等待阻塞是，在阻塞的过程中，会先把进程的 pcb 保存到外存，等待着某个事件的发生，当事件发生的时候，会把进程的 pcb 重新加载到内存，然后进入就绪态 阻塞态的终止是需要另一个进程的提醒的，一个进程是不能够主动的切换阻塞状态的"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-26T15:15:38.000Z"}],["meta",{"property":"article:author","content":"bluestudyhard"}],["meta",{"property":"article:modified_time","content":"2024-02-26T15:15:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-02-26T15:15:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"bluestudyhard\\",\\"url\\":\\"https://github.com/bluestudyhard?tab=repositories\\"}]}"]]},"headers":[{"level":2,"title":"什么是进程","slug":"什么是进程","link":"#什么是进程","children":[{"level":3,"title":"进程的状态","slug":"进程的状态","link":"#进程的状态","children":[]},{"level":3,"title":"进程标识符 pcb","slug":"进程标识符-pcb","link":"#进程标识符-pcb","children":[]},{"level":3,"title":"信号量机制","slug":"信号量机制","link":"#信号量机制","children":[]}]}],"git":{"createdTime":1708960538000,"updatedTime":1708960538000,"contributors":[{"name":"bluestudyhard","email":"3164752596@qq.com","commits":1}]},"readingTime":{"minutes":2.37,"words":710},"filePathRelative":"计算机基础/操作系统/进程，线程.md","localizedDate":"2024年2月26日","excerpt":"<h2> 什么是进程</h2>\\n<p>进程其实就是本质上就是系统上运行的一个程序，系统开辟出了一块内存空间，然后由 CPU 来逐行读取里面的指令，执行里面的指令</p>\\n<h3> 进程的状态</h3>\\n<p>创建态，就绪态，运行态，阻塞态，终止态</p>\\n<p>创建态，new 一个进程，分配内存空间，分配 pcb</p>\\n<p>就绪态，进程已经创建完毕，等待着 cpu 的调度</p>\\n<p>运行态，进程在 cpu 上运行</p>\\n<p>阻塞态，进程在等待着某个事件的发生，比如说等待着 IO，那么这个时候进程会被调度进入阻塞队列</p>\\n<p>阻塞态又分就绪阻塞和等待阻塞<br>\\n就绪阻塞在再次进入内存的时候可以直接运行<br>\\n等待阻塞是，在阻塞的过程中，会先把进程的 pcb 保存到外存，等待着某个事件的发生，当事件发生的时候，会把进程的 pcb 重新加载到内存，然后进入就绪态<br>\\n阻塞态的终止是需要另一个进程的提醒的，一个进程是不能够主动的切换阻塞状态的</p>","autoDesc":true}`);export{e as data};
