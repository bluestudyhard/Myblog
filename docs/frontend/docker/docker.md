## docker 基本知识

容器是由镜像实例化而来，这和我们学习的面向对象的概念十分相似，我们可以把镜像看作类，把容器看作类实例化后的对象。

也可以说镜像是文件, 容器是进程。 容器是基于镜像创建的, 即容器中的进程依赖于镜像中的文件, 这里的文件包括进程运行所需要的可执行文件， 依赖软件， 库文件， 配置文件等等...
docker 的镜像概念类似虚拟机的镜像。是一个只读的模板，一个独立的文件系统，包括运行容器所需的数据，可以用来创建新的容器。

例如：一个镜像可以包含一个完整的 ubuntu 操作系统环境，里面仅安装了 mysql 或用户需要的其他应用程序。

docker 镜像实际上是由一层一层的系统文件组成，这种层级的文件系统被称为 UnionFS( Union file system 统一文件系统)，镜像可以基于 dockerfile 构建，dockerfile 是一个描述文件，里面包含了若干条密令，每条命令都会对基础文件系统创建新的层次结构。

docker 提供了一个很简单的机制来创建镜像或更新现有的镜像。用户甚至可以从其他人那里下载一个已经做好的镜像直接使用。（镜像是只读的，可以理解为静态文件）

docker 利用容器来运行应用：docker 容器是由 docker 镜像创建的运行实例。docker 容器类似虚拟机，可以执行包含启动，停止，删除等。每个容器间是相互隔离的。容器中会运行特定的运用，包含特定应用的代码及所需的依赖文件。可以把容器看作一个简易版的 linux 环境（包含 root 用户权限，进程空间，用户空间和网络空间等）和运行在其中的应用程序。

相对于镜像来说容器是动态的，容器在启动的时候创建了一层可写层次作为最上层。

docker 仓库：如果使用了 git 和 github 就很容易理解 docker 的仓库概念。docker 仓库概念和 git 类似。

docker 仓库是用来包含镜像的位置，docker 提供了一个注册服务器（register）来保存多个仓库，每个仓库又可以包含多个具备不同 tag 的镜像，

docker 运作中使用的默认仓库是 docker hub 公共仓库。

仓库支持的操作类似 git，当用户创建了自己的镜像之后就可以使用 push 命令将它上传到共有或者私有的仓库。这样下次再另外一台机器上使用这个镜像的时候只需要从仓库里面 pull 下来就可以了。

## docker 镜像

### dockerfile 详解

- ARG 相当于变量，可以在 docker build 的时候传入，例如 docker build --build-arg VERSION=1.0.0 .，这样在 dockerfile 里面就可以使用 ${VERSION} 来引用这个变量了

- FROM 指定基础镜像，必须是第一个命令，后续的命令都是基于这个镜像的

- RUN 表示容器启动时运行的命令，可以有多个，每个 RUN 都会在上一个 RUN 的基础上执行，例如 RUN apt-get update && apt-get install -y vim
- CMD 表示容器启动时运行的命令，只能有一个，如果有多个，只有最后一个生效，如果 docker run 的时候指定了命令，那么 CMD 的命令会被忽略，例如 CMD ["java", "-jar", "app.jar"]，这里的 CMD 会被忽略，因为 docker run 的时候指定了 java -jar app.jar
- COPY
格式为
```COPY <src> <dest>。```
复制本地主机的 （为 Dockerfile 所在目录的相对路径）到容器中的 。
当使用本地目录为源目录时，推荐使用 COPY。
比如说copy .. 表示将dokerfile所在目录的上一级目录的所有文件复制到容器中的 /app 目录下

- WORKDIR 表示容器启动时的工作目录，如果不存在会自动创建，例如 WORKDIR /app，这样在后续的命令中就可以使用相对路径了，例如 COPY . .，这里的第二个 . 就表示 /app

- ENV 设置环境变量，格式为``` ENV <key> <value>```，例如 ENV JAVA_OPTS="-Xms256m -Xmx512m -XX:MetaspaceSize=256m -XX:MaxMetaspaceSize=512m"，这样在后续的命令中就可以使用 ${JAVA_OPTS} 来引用这个环境变量了

- EXPOSE 暴露端口，格式为``` EXPOSE <port> [<port>...]```，例如 EXPOSE 8080，这样在 docker run 的时候就可以使用 -p 8080:8080 来映射端口了